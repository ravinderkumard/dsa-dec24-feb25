URL: https://leetcode.com/problems/valid-palindrome/description/

# 125. Valid Palindrome

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

 
Example 1:

Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.

Example 2:

Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.

Example 3:

Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.

 
Constraints:

	1 <= s.length <= 2 * 105
	s consists only of printable ASCII characters.


## Problem Understanding
The goal is to check if a string is a palindrome, considering only alphanumeric characters and ignoring cases.
The problem has 2 key constraints:
1. Ignore non-alphanumeric characters.
2. Case-insensitive comparison.


## Intuition Behind Approach
The key idea is:
- Palindrome means the string reads the same forward and backword.
- We don't want extra space like building a filtered string --> iinstead, use two pointers to scan from both ends toward the middle.
- Skip invalid characters on the fly to avoid unnecessary memory usage.

This leads to:
1. Two pointers: one starting at the left, one at the right.
2. Skip non-alphanumeric characters before comparing.
3. Compare characters in a case-insenstive manner.
4. Move pointers inward until they cross.

This gives **O(n)** time complexity with **O(1)** extra space.

## Complexity Analysis
- Time Complexity: O(N) -> Each character visited at most once.
- Space Complexity: O(1) -> Constant extra space, just pointers.

Approach:
1. Use left and right pointers, and check if character is not alpha or digit increase left poitner and similarly 
decrease right pointer. 
2. if charaters are matching move left and right pointers respectively
3. return false if characters are not matching


```Java```
class Solution {
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length()-1;
        while(left<right){

            while(left<right && left<s.length() && !checkIfAlphaOrNumeric(s.charAt(left))){
                left++;
            }
            while(left<right && right>=0 && !checkIfAlphaOrNumeric(s.charAt(right))){
                right--;
            }
            if(Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    private boolean checkIfAlphaOrNumeric(char ch){
        if(Character.isAlphabetic(ch)){
            return true;
        }
        return Character.isDigit(ch);
    }
}
```


```Java```
class Solution {
    public boolean isPalindrome(String s) {
        List<Character> finalString = new ArrayList<>();
        for(int i=0;i<s.length();i++){
            char ch = s.charAt(i);
            if(checkIfAlphaOrNumeric(ch)){
                finalString.add(ch);
            }
        }
        int left = 0;
        int right = finalString.size()-1;
        while(left<right){
            if(Character.toLowerCase(finalString.get(left))!=Character.toLowerCase(finalString.get(right))){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    private boolean checkIfAlphaOrNumeric(char ch){
        if(Character.isAlphabetic(ch)){
            return true;
        }
        return Character.isDigit(ch);
    }
}
```

