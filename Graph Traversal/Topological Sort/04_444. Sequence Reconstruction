444. Sequence Reconstruction

URL: https://leetcode.com/problems/sequence-reconstruction/description/

444. Sequence Reconstruction

You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.

Check if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.

	For example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].
	While for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.

Return true if nums is the only shortest supersequence for sequences, or false otherwise.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

 
Example 1:

Input: nums = [1,2,3], sequences = [[1,2],[1,3]]
Output: false
Explanation: There are two possible supersequences: [1,2,3] and [1,3,2].
The sequence [1,2] is a subsequence of both: [1,2,3] and [1,3,2].
The sequence [1,3] is a subsequence of both: [1,2,3] and [1,3,2].
Since nums is not the only shortest supersequence, we return false.

Example 2:

Input: nums = [1,2,3], sequences = [[1,2]]
Output: false
Explanation: The shortest possible supersequence is [1,2].
The sequence [1,2] is a subsequence of it: [1,2].
Since nums is not the shortest supersequence, we return false.

Example 3:

Input: nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
Output: true
Explanation: The shortest possible supersequence is [1,2,3].
The sequence [1,2] is a subsequence of it: [1,2,3].
The sequence [1,3] is a subsequence of it: [1,2,3].
The sequence [2,3] is a subsequence of it: [1,2,3].
Since nums is the only shortest supersequence, we return true.

 
Constraints:

	n == nums.length
	1 <= n <= 104
	nums is a permutation of all the integers in the range [1, n].
	1 <= sequences.length <= 104
	1 <= sequences[i].length <= 104
	1 <= sum(sequences[i].length) <= 105
	1 <= sequences[i][j] <= n
	All the arrays of sequences are unique.
	sequences[i] is a subsequence of nums.





class Solution {
    public boolean sequenceReconstruction(int[] nums, List<List<Integer>> sequences) {
        int n = nums.length;
        int[] inDegree = new int[n+1];
        List<List<Integer>> graph = new ArrayList<>();
        for(int listSize = 0;listSize<=n;listSize++){
            graph.add(new ArrayList<>());
        }
        for(List<Integer> seq :sequences){
            for(int index=1;index<seq.size();index++){
                int nodeA = seq.get(index-1);
                int nodeB = seq.get(index);
                if(nodeA<1||nodeA>n||nodeB<1||nodeB>n) return false;

                graph.get(nodeA).add(nodeB);
                inDegree[nodeB]++;
            }
        }
        Queue<Integer> topSort = new LinkedList<>();
        for(int node =1;node<=n;node++){
            if(inDegree[node]==0){
                topSort.offer(node);
            }
        }
        for(int index=0;index<n;index++){
            if(topSort.size()>1||nums[index]!=topSort.peek()){
                return false;
            }
            int curr = topSort.poll();
            for(int next:graph.get(curr)){
                inDegree[next]--;
                if(inDegree[next]==0){
                    topSort.offer(next);
                }
            }
        }
        return true;
    }
}


class Solution {
    public boolean sequenceReconstruction(int[] nums, List<List<Integer>> sequences) {
        int n = nums.length;
        List<Integer>[] g = new List[n + 1];
        int[] indegree = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            g[i] = new ArrayList<>();
        }
        for (List<Integer> se : sequences) {
            int len = se.size();
            for (int i = 1; i < len; i++) {
                g[se.get(i - 1)].add(se.get(i));
                indegree[se.get(i)]++;
            }
        }
        List<Integer> list = new ArrayList<>();
        Queue<Integer> q = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            if (indegree[i] == 0) {
                q.offer(i);
            }
        }
        while (!q.isEmpty()) {
            int len = q.size();
            if (len != 1) {
                return false;
            }
            int cur = q.poll();
            list.add(cur);
            for (int next : g[cur]) {
                indegree[next]--;
                if (indegree[next] == 0) {
                    q.offer(next);
                }
            }
        }
        if (nums.length != list.size()) return false;
        for (int i = 0; i < n; i++) {
            if (nums[i] != list.get(i)) {
                return false;
            }
        }
        return true;
    }
}
