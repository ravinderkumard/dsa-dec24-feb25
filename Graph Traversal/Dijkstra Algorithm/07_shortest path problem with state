Your task is to find a minimum-price flight route from Syrjälä to Metsälä. You have one discount coupon, using which you can halve the price of any single flight during the route. However, you can only use the coupon once.
When you use the discount coupon for a flight whose price is x, its price becomes \lfloor x/2 \rfloor (it is rounded down to an integer).
Input
The first input line has two integers n and m: the number of cities and flight connections. The cities are numbered 1,2,\ldots,n. City 1 is Syrjälä, and city n is Metsälä.
After this there are m lines describing the flights. Each line has three integers a, b, and c: a flight begins at city a, ends at city b, and its price is c. Each flight is unidirectional.
You can assume that it is always possible to get from Syrjälä to Metsälä.
Output
Print one integer: the price of the cheapest route from Syrjälä to Metsälä.
Constraints

2 \le n \le 10^5
1 \le m \le 2 \cdot 10^5
1 \le a,b \le n
1 \le c \le 10^9

Example
Input:
3 4
1 2 3
2 3 1
1 3 7
2 1 5

Output:
2



Got it — this is a shortest path problem with state because we have two choices:

either we haven’t used the discount coupon yet

or we have already used it

We can solve this efficiently with Dijkstra’s algorithm on a layered graph:

Idea

Let dist[u][0] = min cost to reach city u without using the coupon.

Let dist[u][1] = min cost to reach city u after using the coupon.

For each edge (u -> v, cost):

If we haven’t used the coupon:

Go normally: dist[v][0] = min(dist[v][0], dist[u][0] + cost)

Use coupon here: dist[v][1] = min(dist[v][1], dist[u][0] + cost/2)

If coupon already used:

Just pay full cost: dist[v][1] = min(dist[v][1], dist[u][1] + cost)

Answer = dist[n][1] because we want to end with coupon possibly used.

Complexity

Each edge processed at most twice → O((n+m) log n) using priority queue.



import java.io.*;
import java.util.*;

public class Main {
    static class Edge {
        int to;
        long cost;
        Edge(int t, long c) { to = t; cost = c; }
    }

    static class State implements Comparable<State> {
        int node, used;
        long dist;
        State(int n, int u, long d) { node = n; used = u; dist = d; }
        public int compareTo(State o) { return Long.compare(this.dist, o.dist); }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] first = br.readLine().split(" ");
        int n = Integer.parseInt(first[0]);
        int m = Integer.parseInt(first[1]);

        List<List<Edge>> adj = new ArrayList<>();
        for (int i = 0; i <= n; i++) adj.add(new ArrayList<>());

        for (int i = 0; i < m; i++) {
            String[] line = br.readLine().split(" ");
            int a = Integer.parseInt(line[0]);
            int b = Integer.parseInt(line[1]);
            long c = Long.parseLong(line[2]);
            adj.get(a).add(new Edge(b, c));
        }

        long INF = Long.MAX_VALUE / 2;
        long[][] dist = new long[n+1][2];
        for (int i = 1; i <= n; i++) Arrays.fill(dist[i], INF);

        dist[1][0] = 0;
        PriorityQueue<State> pq = new PriorityQueue<>();
        pq.add(new State(1, 0, 0));

        while (!pq.isEmpty()) {
            State cur = pq.poll();
            int u = cur.node, used = cur.used;
            if (cur.dist != dist[u][used]) continue;

            for (Edge e : adj.get(u)) {
                // without coupon
                if (dist[u][used] + e.cost < dist[e.to][used]) {
                    dist[e.to][used] = dist[u][used] + e.cost;
                    pq.add(new State(e.to, used, dist[e.to][used]));
                }
                // use coupon if not used
                if (used == 0) {
                    long discounted = dist[u][0] + e.cost / 2;
                    if (discounted < dist[e.to][1]) {
                        dist[e.to][1] = discounted;
                        pq.add(new State(e.to, 1, discounted));
                    }
                }
            }
        }

        System.out.println(dist[n][1]);
    }
}

