There are n cities and m flight connections between them. Your task is to determine the length of the shortest route from Syrjälä to every city.
Input
The first input line has two integers n and m: the number of cities and flight connections. The cities are numbered 1,2,\dots,n, and city 1 is Syrjälä.
After that, there are m lines describing the flight connections. Each line has three integers a, b and c: a flight begins at city a, ends at city b, and its length is c. Each flight is a one-way flight.
You can assume that it is possible to travel from Syrjälä to all other cities.
Output
Print n integers: the shortest route lengths from Syrjälä to cities 1,2,\dots,n.
Constraints

1 \le n \le 10^5
1 \le m \le 2 \cdot 10^5
1 \le a,b \le n
1 \le c \le 10^9

Example
Input:
3 4
1 2 6
1 3 2
3 2 3
1 3 4

Output:
0 5 2



package com.pkg;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

public class ShortestRoutes {
	static class Edge {
		int to, weight;
		Edge(int to,int weight){
			this.to = to;
			this.weight = weight;
		}
	}
	static class Node implements Comparable<Node>{
		int city;
		long dist;
		Node(int city,long dist){
			this.city = city;
			this.dist = dist;
		}
		public int compareTo(Node other) {
			return Long.compare(this.dist, other.dist);
		}
	}
	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();
		List<List<Edge>> graph = new ArrayList<>();
		for(int i=0;i<=n;i++) {
			graph.add(new ArrayList<>());
		}
		for(int i=0;i<m;i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			graph.get(a).add(new Edge(b,c));
		}
		
		long[] dist = new long[n+1];
		Arrays.fill(dist, Long.MAX_VALUE);
		dist[1] = 0;
		
		PriorityQueue<Node> pq = new PriorityQueue<>();
		pq.add(new Node(1,0));
		while(!pq.isEmpty()) {
			Node curr = pq.poll();
			int u = curr.city;
			long d = curr.dist;
			
			if(d>dist[u]) continue;
			
			for(Edge e:graph.get(u)) {
				int v = e.to;
				long newDist = dist[u]+e.weight;
				if(newDist<dist[v]) {
					dist[v] = newDist;
					pq.add(new Node(v,newDist));
				}
			}
		}
		
		for(int i=1;i<=n;i++) {
			System.out.println(dist[i]);
		}
	}
}
