There are n cities and m flight connections between them. Your task is to determine the length of the shortest route from Syrjälä to every city.
Input
The first input line has two integers n and m: the number of cities and flight connections. The cities are numbered 1,2,\dots,n, and city 1 is Syrjälä.
After that, there are m lines describing the flight connections. Each line has three integers a, b and c: a flight begins at city a, ends at city b, and its length is c. Each flight is a one-way flight.
You can assume that it is possible to travel from Syrjälä to all other cities.
Output
Print n integers: the shortest route lengths from Syrjälä to cities 1,2,\dots,n.
Constraints

1 \le n \le 10^5
1 \le m \le 2 \cdot 10^5
1 \le a,b \le n
1 \le c \le 10^9

Example
Input:
3 4
1 2 6
1 3 2
3 2 3
1 3 4

Output:
0 5 2



What Dijkstra's Algorithm Does

Goal: Find the shortest path from a single source node to all other nodes in a weighted graph.

Requirement: All edge weights must be non-negative (no negative cycles).

Core Idea

Think of it as pouring water from the source node — the water spreads outward, always flowing along the path of least total weight first.
We keep expanding the shortest path found so far until we reach all nodes.

How It Works

Initialization:

Set the distance to the source node as 0.

Set distances to all other nodes as ∞ (infinity) because we don’t know the shortest path yet.

Pick the next closest node:

Use a min-heap / priority queue to always pick the unvisited node with the smallest known distance.

Relax edges:

From this node, check all outgoing edges (u → v, weight).

If the new distance dist[u] + weight is smaller than the current dist[v], update it.

Repeat until all nodes are visited or distances finalized.

Example

Graph:

1 → 2 (6)
1 → 3 (2)
3 → 2 (3)


Steps:

Start at city 1, distance = 0.
Distances: [0, ∞, ∞]

From 1,

to 2: distance = 6

to 3: distance = 2
Distances: [0, 6, 2]

Pick node with smallest distance (city 3, dist = 2).
From 3 → 2: new distance = 2 + 3 = 5 (better than 6).
Distances: [0, 5, 2]

No more updates → Final distances: [0, 5, 2]






package com.pkg;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

public class ShortestRoutes {
	static class Edge {
		int to, weight;
		Edge(int to,int weight){
			this.to = to;
			this.weight = weight;
		}
	}
	static class Node implements Comparable<Node>{
		int city;
		long dist;
		Node(int city,long dist){
			this.city = city;
			this.dist = dist;
		}
		public int compareTo(Node other) {
			return Long.compare(this.dist, other.dist);
		}
	}
	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();
		List<List<Edge>> graph = new ArrayList<>();
		for(int i=0;i<=n;i++) {
			graph.add(new ArrayList<>());
		}
		for(int i=0;i<m;i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			graph.get(a).add(new Edge(b,c));
		}
		
		long[] dist = new long[n+1];
		Arrays.fill(dist, Long.MAX_VALUE);
		dist[1] = 0;
		
		PriorityQueue<Node> pq = new PriorityQueue<>();
		pq.add(new Node(1,0));
		while(!pq.isEmpty()) {
			Node curr = pq.poll();
			int u = curr.city;
			long d = curr.dist;
			
			if(d>dist[u]) continue;
			
			for(Edge e:graph.get(u)) {
				int v = e.to;
				long newDist = dist[u]+e.weight;
				if(newDist<dist[v]) {
					dist[v] = newDist;
					pq.add(new Node(v,newDist));
				}
			}
		}
		
		for(int i=1;i<=n;i++) {
			System.out.println(dist[i]);
		}
	}
}
