261. Graph Valid Tree

You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.

Return true if the edges of the given graph make up a valid tree, and false otherwise.

 

Example 1:


Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true
Example 2:


Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
Output: false
 

Constraints:

1 <= n <= 2000
0 <= edges.length <= 5000
edges[i].length == 2
0 <= ai, bi < n
ai != bi
There are no self-loops or repeated edges.



Mentor: Is checking for cycles alone enough to confirm if the graph is a valid tree?
Candidate: No, also the number of edges should be one less than the number of nodes.

Mentor: Correct. But if edges = n-1, does that guarantee the graph is connected?
Candidate: Not always. We also need to check if the graph is connected.

Mentor: Good. How will you verify connectivity?
Candidate: By using Union-Find to ensure all nodes belong to a single connected component.

Mentor: What if the graph has n-1 edges but still has isolated nodes?
Candidate: Then Union-Find will reveal multiple parents; in that case, itâ€™s not a tree.

Mentor: And what if two nodes already share the same parent during union?
Candidate: That means they are in the same component.
Mentor: Not quite! That actually indicates a cycle. How does your code handle this?
Candidate: My code returns false when a cycle is detected.

Mentor: Nice. How does your code handle large inputs (e.g., n=2000, edges=5000)?
Candidate: The edges.length == n-1 check filters invalid cases. With path compression, Union-Find runs in near O(1), so it scales well.

Mentor: What about when edges = n-1 but nodes are still disconnected, like in this input:
n=5, edges=[[0,1],[2,3],[3,4],[1,4]]?
Candidate: Then path compression reveals multiple parents, so it returns false.

Mentor: Okay. How confident are you about your rank updates in Union-Find?
Candidate: Yes, though we should compare rank[findX] and rank[findY] instead of just findX and findY.

Mentor: Great adjustment! Thatâ€™s the more robust approach. Do you want to cover anything else or wrap up?
Candidate: Wrap up.

ðŸ“Œ Chat Summary
The candidate demonstrated strong understanding of the Graph Valid Tree problem, identifying the two key conditions:

The graph must have exactly n-1 edges.

The graph must be acyclic and connected, which was ensured using Union-Find with path compression.

The discussion also clarified:

Detecting cycles via Union-Find (if union finds same parent, cycle exists).

Ensuring connectivity by verifying all nodes fall under a single parent.

Efficiency of Union-Find for large inputs.

The importance of using rank-based union updates instead of comparing node IDs directly.

The candidate handled edge cases well after guidance and showed readiness to optimize code robustness.


Here is your interview feedback summary based on your recent mock session focused on the "Graph Valid Tree" problem, tailored for your backend developer interview preparation:

ðŸ§  Detailed Feedback:
âœ… What You Did Well:
You clearly understood the two essential properties of a tree in a graphâ€”cycle detection and connectivity . You also demonstrated solid knowledge of the Union-Find algorithm, including its efficiency and path compression benefits , which is highly relevant for backend system design and large-scale data handling.

âš ï¸ Areas for Improvement:
Your initial responses sometimes missed subtle distinctions (e.g., what cycle detection during union actually means) . When discussing implementation details, you were a bit briefâ€”especially on how union and find should use rank for optimal performance. In a MAANG or product-based interview, deeper clarity and explicit reasoning about edge cases and code robustness will help you stand out.

â±ï¸ Time Management:
You completed the interview in about 34 minutesâ€”well under the expected 60 minutes. This shows strong efficiency and confidence , but be cautious not to rush through detailed explanations or miss opportunities to elaborate, especially with high-bar interviewers.





class UnionFind{
    int[] parent;
    int[] rank;
    UnionFind(int n){
        parent = new int[n];
        rank = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
            rank[i] = 1;
        }
    }
    int find(int x){
        int result = x; 
        while(parent[result]!=result){
            parent[result] = parent[parent[result]];
            result = parent[result];
        }   
        return result;
    }
    boolean union(int x,int y){
        int findX = find(x);
        int findY = find(y);
        if(findX==findY){
            return false;
        } else {
            if(rank[findX]>rank[findY]){
                parent[findY] = findX;
                rank[findX] += rank[findY];
            } else {
                parent[findX] = findY;
                rank[findY] += rank[findX];
            }
        }
        return true;
    }
}
class Solution {
    public boolean validTree(int n, int[][] edges) {
        if(edges.length!=n-1){
            return false;
        }
        UnionFind uf = new UnionFind(n);
        for(int[] edge:edges){
            if(!uf.union(edge[0],edge[1])){
                return false;
            }
        }
        return true;
    }
}
